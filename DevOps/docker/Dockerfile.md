# Dockerfile reference

Docker может создавать образы автоматически, читая инструкции из Dockerfile. Dockerfile — это текстовый документ, содержащий все команды, которые пользователь может вызвать в командной строке для сборки образа. На этой странице описаны команды, которые вы можете использовать в Dockerfile.



## .dockerignore file

.dockerignore в корневом каталоге контекста. Если этот файл существует, интерфейс командной строки изменяет контекст, чтобы исключить файлы и каталоги, соответствующие шаблонам в нем. Это помогает избежать ненужной отправки больших или конфиденциальных файлов и каталогов демону и возможного добавления их в образы с помощью ADD или COPY.

| Правило | Результат |
|----|----|
| # comment | Игнорируется (комментарии) |
| */temp* | Исключает файлы, название которых называется на temp в любом непосредственном подкаталоге корня. Например, простой файл /somedir/temporary.txt исключается, как и каталог /somedir/temp. |
| */*/temp* | Исключите файлы и каталоги, начинающиеся с temp, из любого подкаталога, который находится на два уровня ниже корня. Например, исключается файл /somedir/subdir/temporary.txt. |
| temp? | Исключить файлы и каталоги в корневом каталоге, имена которых являются односимвольным расширением temp. Например, /tempa и /tempb исключаются. |
| ! | Позволяет добавить файл не смотря на правило исключения |

## FROM

Инструкция FROM инициализирует новую стадию сборки и устанавливает базовый образ для последующих инструкций. Таким образом, действительный файл Dockerfile должен начинаться с инструкции FROM. Изображение может быть любым допустимым изображением — особенно легко начать с извлечения изображения из общедоступных репозиториев.

## RUN

RUN имеет две формы инструкции:
- `RUN <command>`
- `RUN ["executable", "param1", "param2"]`

Инструкция RUN выполнит любые команды в новом слое поверх текущего изображения и зафиксирует результаты. Полученный зафиксированный образ будет использоваться для следующего шага в Dockerfile.

Распределение инструкций RUN и генерация коммитов соответствует основным концепциям Docker, где коммиты дешевы, а контейнеры можно создавать из любой точки истории образа, как в системе управления версиями.

Форма exec позволяет избежать искажения строки оболочки и выполнять команды RUN с использованием базового образа, который не содержит указанный исполняемый файл оболочки.

Оболочку по умолчанию для формы оболочки можно изменить с помощью команды SHELL.

В форме оболочки вы можете использовать \ (обратная косая черта), чтобы продолжить выполнение одной инструкции RUN на следующей строке.

В отличие от формы shell, форма exec не вызывает командную оболочку. Это означает, что нормальной обработки shell не происходит. Например, `RUN [ "echo", "$HOME" ]` не будет выполнять подстановку переменных в $HOME. Если вам нужна обработка shell, то либо используйте форму shell, либо запустите оболочку напрямую, например: `RUN [ "sh", "-c", "echo $HOME" ]`. При использовании формы exec и непосредственном выполнении shell, как и в случае с формой shell, расширение переменной среды выполняет оболочка, а не docker.

Кэш для инструкций RUN не становится недействительным автоматически во время следующей сборки. Кэш для такой инструкции, как `RUN apt-get dist-upgrade -y`, будет повторно использован во время следующей сборки. Кэш для инструкций RUN можно сделать недействительным с помощью флага `--no-cache`, например, `docker build --no-cache`.

Кэш для инструкций RUN можно сделать недействительным с помощью инструкций ADD и COPY.

### RUN --mount

`RUN --mount` позволяет вам создавать монтирования, к которым может получить доступ процесс, работающий как часть сборки. Это можно использовать для привязки файлов из другой части сборки без копирования, доступа к секретам сборки или сокетам ssh-агента или создания мест кеша для ускорения сборки.

Типы монтирования:
- bind: Контекстные каталоги привязки-монтирования (только для чтения).
- cache: Монтирование временных каталогов в кеш для компиляторов и менеджеров пакетов.
- secret: Разрешить контейнеру сборки доступ к защищенным файлам, таким как закрытые ключи, без их запекания в образ.
- ssh: Разрешить контейнеру сборки доступ к ключам SSH через агенты SSH с поддержкой фраз-паролей.

### RUN --network

Позволяет контролировать, в какой сетевой среде выполняется команда.
Типы:
- default: Запуск в дефолтной сети.
- none: Запуск с отсутствующим доступом к сети.
- host: Запуск в сетевом окружении хоста.

### RUN --security

С `--security=insecure` билдер запускает команду без песочницы в небезопасном режиме, что позволяет запускать потоки, требующие повышенных привилегий (например, containerd). Это эквивалентно запуску docker run `--privileged`.

## CMD

Используется для указания программ, которые выполняются при запуске контейнера.

Инструкция CMD имеет три формы:
- `CMD ["executable","param1","param2"]` (exec форма, это предпочтительная форма)
- `CMD ["param1","param2"]` (как параметры по умолчанию для ENTRYPOINT)
- `CMD command param1 param2` (shell форма)

Только одна инструкция CMD может быть выполнена. Если несколько таких инструкций в файле, то выполнится только последняя. 

Основная цель CMD — предоставить значения по умолчанию для исполняемого контейнера. Эти значения по умолчанию могут включать исполняемый файл или исключать исполняемый файл, и в этом случае вы также должны указать инструкцию ENTRYPOINT.

Если CMD используется для предоставления аргументов по умолчанию для инструкции ENTRYPOINT, обе инструкции CMD и ENTRYPOINT должны быть указаны в формате массива JSON.

Команды CMD игнорируются Daemon_ом, когда в команде запуска docker указаны параметры, в то время как инструкции ENTRYPOINT не игнорируются, а вместо этого добавляются как параметры командной строки, рассматривая их как аргументы команды.

Если вы хотите, чтобы ваш контейнер каждый раз запускал один и тот же исполняемый файл, вам следует рассмотреть возможность использования ENTRYPOINT в сочетании с CMD.

## ENTRYPOINT

ENTRYPOINT позволяет настроить контейнер, который будет работать как исполняемый файл.

Аргументы командной строки для запуска docker `<image>` будут добавлены после всех элементов в форме exec ENTRYPOINT и переопределят все элементы, указанные с помощью CMD. Это позволяет передавать аргументы в точку входа, т. е. `docker run <image> -d` передаст аргумент `-d` в точку входа. Вы можете переопределить инструкцию ENTRYPOINT, используя флаг `docker run --entrypoint`.

### Взаимодействие CMD и ENTRYPOINT

1. Dockerfile должен указывать хотя бы одну из команд CMD или ENTRYPOINT.
1. ENTRYPOINT должен быть определен при использовании контейнера в качестве исполняемого файла.
1. CMD следует использовать как способ определения аргументов по умолчанию для команды ENTRYPOINT или для выполнения специальной команды в контейнере.
1. CMD будет переопределен при запуске контейнера с альтернативными аргументами.

Описание использования Entrypoint

| | No ENTRYPOINT | ENTRYPOINT exec_entry p1_entry | ENTRYPOINT [“exec_entry”, “p1_entry”] |
|----|----|----|----|
| No CMD | error, not allowed | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry |
| CMD [“exec_cmd”, “p1_cmd”] | exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry exec_cmd p1_cmd |
| CMD exec_cmd p1_cmd | /bin/sh -c exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd |

## LABEL

Инструкция LABEL добавляет к image метаданные. LABEL — это пара ключ-значение. Чтобы включить пробелы в значение LABEL, используйте кавычки и обратную косую черту, как при синтаксическом анализе командной строки. Несколько примеров использования:
```
LABEL "com.example.vendor"="ACME Incorporated"
LABEL com.example.label-with-value="foo"
LABEL version="1.0"
LABEL description="This text illustrates \
that label-values can span multiple lines."
```

## MAINTAINER

## EXPOSE

Инструкция EXPOSE информирует Docker о том, что контейнер прослушивает указанные сетевые порты во время выполнения. Вы можете указать, прослушивает ли порт TCP или UDP, и по умолчанию используется TCP, если протокол не указан.

Инструкция EXPOSE фактически не публикует порт. Он функционирует как тип документации между человеком, который создает образ, и человеком, который запускает контейнер, о том, какие порты предназначены для публикации. Чтобы фактически опубликовать порт при запуске контейнера, используйте флаг -p при запуске docker, чтобы опубликовать и сопоставить один или несколько портов, или флаг -P, чтобы опубликовать все открытые порты и сопоставить их с портами высокого порядка.

По умолчанию EXPOSE предполагает TCP. Вы также можете указать UDP:

## ENV

Инструкция ENV устанавливает для переменной среды `<key>` значение `<value>`. Это значение будет в среде для всех последующих инструкций на этапе сборки и во многих случаях может быть заменено встроенным. Значение будет интерпретировано для других переменных среды, поэтому символы кавычек будут удалены, если они не экранированы. Как и при синтаксическом анализе командной строки, для включения пробелов в значения можно использовать кавычки и обратную косую черту.
```
ENV MY_NAME="John Doe"
ENV MY_DOG=Rex\ The\ Dog
ENV MY_CAT=fluffy
```

## ADD

Инструкция ADD копирует новые файлы, каталоги или URL-адреса удаленных файлов из `<src>` и добавляет их в файловую систему образа по пути `<dest>`.

Можно указать несколько ресурсов `<src>`, но если они являются файлами или каталогами, их пути интерпретируются как относительные к источнику контекста сборки.
Каждый `<src>` может содержать подстановочные знаки.

## COPY

Инструкция COPY копирует новые файлы или каталоги из `<src>` и добавляет их в файловую систему контейнера по пути `<dest>`.
Можно указать несколько ресурсов `<src>`, но пути к файлам и каталогам будут интерпретироваться относительно источника контекста сборки.
Каждый `<src>` может содержать подстановочные знаки, и сопоставление будет выполняться с использованием правил Go filepath.Match.

Когда используется `--link`, ваши исходные файлы копируются в пустой каталог назначения. Этот каталог превращается в слой, который связан поверх вашего предыдущего состояния.















