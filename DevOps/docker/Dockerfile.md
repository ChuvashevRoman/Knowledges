# Dockerfile reference

Docker может создавать образы автоматически, читая инструкции из Dockerfile. Dockerfile — это текстовый документ, содержащий все команды, которые пользователь может вызвать в командной строке для сборки образа. На этой странице описаны команды, которые вы можете использовать в Dockerfile.



## .dockerignore file

.dockerignore в корневом каталоге контекста. Если этот файл существует, интерфейс командной строки изменяет контекст, чтобы исключить файлы и каталоги, соответствующие шаблонам в нем. Это помогает избежать ненужной отправки больших или конфиденциальных файлов и каталогов демону и возможного добавления их в образы с помощью ADD или COPY.

| Правило | Результат |
|----|----|
| # comment | Игнорируется (комментарии) |
| */temp* | Исключает файлы, название которых называется на temp в любом непосредственном подкаталоге корня. Например, простой файл /somedir/temporary.txt исключается, как и каталог /somedir/temp. |
| */*/temp* | Исключите файлы и каталоги, начинающиеся с temp, из любого подкаталога, который находится на два уровня ниже корня. Например, исключается файл /somedir/subdir/temporary.txt. |
| temp? | Исключить файлы и каталоги в корневом каталоге, имена которых являются односимвольным расширением temp. Например, /tempa и /tempb исключаются. |
| ! | Позволяет добавить файл не смотря на правило исключения |

## FROM

Инструкция FROM инициализирует новую стадию сборки и устанавливает базовый образ для последующих инструкций. Таким образом, действительный файл Dockerfile должен начинаться с инструкции FROM. Изображение может быть любым допустимым изображением — особенно легко начать с извлечения изображения из общедоступных репозиториев.

- ARG — единственная инструкция, которая может предшествовать FROM в Dockerfile. См. Переменная инициализированная в ARG может быть передана в качестве имаджа, который будет использован при билде контейнера.
- FROM может появляться несколько раз в одном Dockerfile для создания нескольких образов или использования одного этапа сборки в качестве зависимости для другого. Просто запишите идентификатор последнего изображения, выведенный фиксацией, перед каждой новой инструкцией FROM. Каждая инструкция FROM очищает любое состояние, созданное предыдущими инструкциями.
- При желании можно дать имя новому этапу сборки, добавив имя AS в инструкцию FROM. Это имя можно использовать в последующих инструкциях FROM и COPY --from=<name> для ссылки на образ, созданный на этом этапе.
- Значения тега или дайджеста являются необязательными. Если вы опустите любой из них, построитель по умолчанию примет последний тег. Построитель возвращает ошибку, если не может найти значение тега.

## RUN

RUN имеет две формы инструкции:
- `RUN <command>`
- `RUN ["executable", "param1", "param2"]`

Инструкция RUN выполнит любые команды в новом слое поверх текущего изображения и зафиксирует результаты. Полученный зафиксированный образ будет использоваться для следующего шага в Dockerfile.

Распределение инструкций RUN и генерация коммитов соответствует основным концепциям Docker, где коммиты дешевы, а контейнеры можно создавать из любой точки истории образа, как в системе управления версиями.

Форма exec позволяет избежать искажения строки оболочки и выполнять команды RUN с использованием базового образа, который не содержит указанный исполняемый файл оболочки.

Оболочку по умолчанию для формы оболочки можно изменить с помощью команды SHELL.

В форме оболочки вы можете использовать \ (обратная косая черта), чтобы продолжить выполнение одной инструкции RUN на следующей строке.

В отличие от формы shell, форма exec не вызывает командную оболочку. Это означает, что нормальной обработки shell не происходит. Например, `RUN [ "echo", "$HOME" ]` не будет выполнять подстановку переменных в $HOME. Если вам нужна обработка shell, то либо используйте форму shell, либо запустите оболочку напрямую, например: `RUN [ "sh", "-c", "echo $HOME" ]`. При использовании формы exec и непосредственном выполнении shell, как и в случае с формой shell, расширение переменной среды выполняет оболочка, а не docker.

Кэш для инструкций RUN не становится недействительным автоматически во время следующей сборки. Кэш для такой инструкции, как `RUN apt-get dist-upgrade -y`, будет повторно использован во время следующей сборки. Кэш для инструкций RUN можно сделать недействительным с помощью флага `--no-cache`, например, `docker build --no-cache`.

Кэш для инструкций RUN можно сделать недействительным с помощью инструкций ADD и COPY.

### RUN --mount

`RUN --mount` позволяет вам создавать монтирования, к которым может получить доступ процесс, работающий как часть сборки. Это можно использовать для привязки файлов из другой части сборки без копирования, доступа к секретам сборки или сокетам ssh-агента или создания мест кеша для ускорения сборки.

Типы монтирования:
- bind: Контекстные каталоги привязки-монтирования (только для чтения).
- cache: Монтирование временных каталогов в кеш для компиляторов и менеджеров пакетов.
- secret: Разрешить контейнеру сборки доступ к защищенным файлам, таким как закрытые ключи, без их запекания в образ.
- ssh: Разрешить контейнеру сборки доступ к ключам SSH через агенты SSH с поддержкой фраз-паролей.

### RUN --network

Позволяет контролировать, в какой сетевой среде выполняется команда.
Типы:
- default: Запуск в дефолтной сети.
- none: Запуск с отсутствующим доступом к сети.
- host: Запуск в сетевом окружении хоста.

### RUN --security

С `--security=insecure` билдер запускает команду без песочницы в небезопасном режиме, что позволяет запускать потоки, требующие повышенных привилегий (например, containerd). Это эквивалентно запуску docker run `--privileged`.

## Примеры многострочных скриптов

```
# syntax=docker/dockerfile:1
FROM debian
RUN <<EOT bash
  apt-get update
  apt-get install -y vim
EOT

```

## CMD

Используется для указания программ, которые выполняются при запуске контейнера.

Инструкция CMD имеет три формы:
- `CMD ["executable","param1","param2"]` (exec форма, это предпочтительная форма)
- `CMD ["param1","param2"]` (как параметры по умолчанию для ENTRYPOINT)
- `CMD command param1 param2` (shell форма)

Только одна инструкция CMD может быть выполнена. Если несколько таких инструкций в файле, то выполнится только последняя. 

Основная цель CMD — предоставить значения по умолчанию для исполняемого контейнера. Эти значения по умолчанию могут включать исполняемый файл или исключать исполняемый файл, и в этом случае вы также должны указать инструкцию ENTRYPOINT.

Если CMD используется для предоставления аргументов по умолчанию для инструкции ENTRYPOINT, обе инструкции CMD и ENTRYPOINT должны быть указаны в формате массива JSON.

Команды CMD игнорируются Daemon_ом, когда в команде запуска docker указаны параметры, в то время как инструкции ENTRYPOINT не игнорируются, а вместо этого добавляются как параметры командной строки, рассматривая их как аргументы команды.

Если вы хотите, чтобы ваш контейнер каждый раз запускал один и тот же исполняемый файл, вам следует рассмотреть возможность использования ENTRYPOINT в сочетании с CMD.

## ENTRYPOINT

ENTRYPOINT позволяет настроить контейнер, который будет работать как исполняемый файл.

Аргументы командной строки для запуска docker `<image>` будут добавлены после всех элементов в форме exec ENTRYPOINT и переопределят все элементы, указанные с помощью CMD. Это позволяет передавать аргументы в точку входа, т. е. `docker run <image> -d` передаст аргумент `-d` в точку входа. Вы можете переопределить инструкцию ENTRYPOINT, используя флаг `docker run --entrypoint`.

### Взаимодействие CMD и ENTRYPOINT

1. Dockerfile должен указывать хотя бы одну из команд CMD или ENTRYPOINT.
1. ENTRYPOINT должен быть определен при использовании контейнера в качестве исполняемого файла.
1. CMD следует использовать как способ определения аргументов по умолчанию для команды ENTRYPOINT или для выполнения специальной команды в контейнере.
1. CMD будет переопределен при запуске контейнера с альтернативными аргументами.

Описание использования Entrypoint

| | No ENTRYPOINT | ENTRYPOINT exec_entry p1_entry | ENTRYPOINT [“exec_entry”, “p1_entry”] |
|----|----|----|----|
| No CMD | error, not allowed | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry |
| CMD [“exec_cmd”, “p1_cmd”] | exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry exec_cmd p1_cmd |
| CMD exec_cmd p1_cmd | /bin/sh -c exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd |

## LABEL

Инструкция LABEL добавляет к image метаданные. LABEL — это пара ключ-значение. Чтобы включить пробелы в значение LABEL, используйте кавычки и обратную косую черту, как при синтаксическом анализе командной строки. Несколько примеров использования:
```
LABEL "com.example.vendor"="ACME Incorporated"
LABEL com.example.label-with-value="foo"
LABEL version="1.0"
LABEL description="This text illustrates \
that label-values can span multiple lines."
```

## MAINTAINER

## EXPOSE

Инструкция EXPOSE информирует Docker о том, что контейнер прослушивает указанные сетевые порты во время выполнения. Вы можете указать, прослушивает ли порт TCP или UDP, и по умолчанию используется TCP, если протокол не указан.

Инструкция EXPOSE фактически не публикует порт. Он функционирует как тип документации между человеком, который создает образ, и человеком, который запускает контейнер, о том, какие порты предназначены для публикации. Чтобы фактически опубликовать порт при запуске контейнера, используйте флаг -p при запуске docker, чтобы опубликовать и сопоставить один или несколько портов, или флаг -P, чтобы опубликовать все открытые порты и сопоставить их с портами высокого порядка.

По умолчанию EXPOSE предполагает TCP. Вы также можете указать UDP:

## ENV

Инструкция ENV устанавливает для переменной среды `<key>` значение `<value>`. Это значение будет в среде для всех последующих инструкций на этапе сборки и во многих случаях может быть заменено встроенным. Значение будет интерпретировано для других переменных среды, поэтому символы кавычек будут удалены, если они не экранированы. Как и при синтаксическом анализе командной строки, для включения пробелов в значения можно использовать кавычки и обратную косую черту.
```
ENV MY_NAME="John Doe"
ENV MY_DOG=Rex\ The\ Dog
ENV MY_CAT=fluffy
```

## ARG

ARG необходим для определения переменных, которые необходимо определить при билде контейнера при помощи флага `docker build --build-arg <varname>=<value>`. При этом, если переменная не будет объявлена в докерфайле - билд упадёт с ошибкой.

ARG инструкция может также определять дефолтное значение, например:
```
ARG user1=someuser
```
ARG можно использовать совместно с ENV. ENV инструкция всегда отменяет ARG инструкцию с таким же именем
В отличие от инструкции ARG значения ENV всегда сохраняются в построенном образе.
Связку двух инструкций можно использовать следующим образом:
```
FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER=${CONT_IMG_VER:-v1.0.0}
RUN echo $CONT_IMG_VER
```

В Docker есть набор предопределенных переменных ARG, которые можно использовать без соответствующей инструкции ARG в Dockerfile.

- HTTP_PROXY
- http_proxy
- HTTPS_PROXY
- https_proxy
- FTP_PROXY
- ftp_proxy
- NO_PROXY
- no_proxy
- ALL_PROXY
- all_proxy

## ADD

Инструкция ADD копирует новые файлы, каталоги или URL-адреса удаленных файлов из `<src>` и добавляет их в файловую систему образа по пути `<dest>`.

Можно указать несколько ресурсов `<src>`, но если они являются файлами или каталогами, их пути интерпретируются как относительные к источнику контекста сборки.
Каждый `<src>` может содержать подстановочные знаки.

## COPY

Инструкция COPY копирует новые файлы или каталоги из `<src>` и добавляет их в файловую систему контейнера по пути `<dest>`.
Можно указать несколько ресурсов `<src>`, но пути к файлам и каталогам будут интерпретироваться относительно источника контекста сборки.
Каждый `<src>` может содержать подстановочные знаки, и сопоставление будет выполняться с использованием правил Go filepath.Match.

Когда используется `--link`, ваши исходные файлы копируются в пустой каталог назначения. Этот каталог превращается в слой, который связан поверх вашего предыдущего состояния.

## VOLUME

Инструкция VOLUME создает точку монтирования с указанным именем и помечает ее как содержащую внешне смонтированные тома из собственного хоста или других контейнеров. Значение может быть массивом JSON, VOLUME ["/var/log/"] или простой строкой с несколькими аргументами, например VOLUME /var/log или VOLUME /var/log /var/db. Для получения дополнительной информации/примеров и инструкций по монтированию через клиент Docker обратитесь к документации «Общие каталоги через тома».

Команда docker run инициализирует только что созданный том любыми данными, которые существуют в указанном месте в базовом образе. Например, рассмотрим следующий фрагмент Dockerfile:
```
FROM ubuntu
RUN mkdir /myvol
RUN echo "hello world" > /myvol/greeting
VOLUME /myvol
```
Этот Dockerfile приводит к созданию образа, который заставляет docker run создавать новую точку монтирования в /myvol и копировать файл приветствия во вновь созданный том.


## USER

```
USER <user>[:<group>]
```
Инструкция USER устанавливает имя пользователя (или UID) и, необязательно, группу пользователей (или GID), которые будут использоваться в качестве пользователя и группы по умолчанию для оставшейся части текущего этапа. Указанный пользователь используется для инструкций RUN и во время выполнения запускает соответствующие команды ENTRYPOINT и CMD.

## WORKDIR

Инструкция WORKDIR устанавливает рабочий каталог для любых инструкций RUN, CMD, ENTRYPOINT, COPY и ADD, которые следуют за ней в Dockerfile. Если WORKDIR не существует, он будет создан, даже если он не используется ни в одной последующей инструкции Dockerfile.

## ONBUILD

Позволяет выполнить определённую инструкцию при использовании образа в качестве базового при билде другого контейнера.

- Когда он встречает инструкцию ONBUILD, сборщик добавляет триггер к метаданным создаваемого образа. Инструкция никак иначе не влияет на текущую сборку.
- В конце сборки список всех триггеров сохраняется в манифесте образа под ключом OnBuild. Их можно проверить с помощью команды docker inspect.
- Позже образ можно использовать как основу для новой сборки с помощью инструкции FROM. В рамках обработки инструкции FROM нижестоящий построитель ищет триггеры ONBUILD и выполняет их в том же порядке, в котором они были зарегистрированы. Если какой-либо из триггеров дает сбой, инструкция FROM прерывается, что, в свою очередь, приводит к сбою сборки. Если все триггеры выполняются успешно, инструкция FROM завершается, и сборка продолжается как обычно.
- Триггеры очищаются от окончательного изображения после выполнения. Другими словами, они не наследуются «внучатскими» сборками.

Например при использовании python приложений:
```
ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
```

## STOPSIGNAL

Инструкция STOPSIGNAL устанавливает сигнал системного вызова, который будет отправлен контейнеру для выхода. Этот сигнал может быть именем сигнала в формате `SIG<NAME>`, например, SIGKILL, или числом без знака, которое соответствует положению в таблице системных вызовов ядра, например 9. По умолчанию используется значение SIGTERM, если оно не определено.

Сигнал остановки по умолчанию для образа можно переопределить для каждого контейнера с помощью флага --stop-signal при запуске и создании докера.

## HEALTHCHECK

- HEALTHCHECK [OPTIONS] CMD command (проверяет работоспособность контейнера выполнив команду внутри контейнера)
- HEALTHCHECK NONE (отключает любую проверку унаследованную от базового образа)

Инструкция HEALTHCHECK сообщает Docker, как протестировать контейнер, чтобы убедиться, что он все еще работает. Это может обнаружить такие случаи, как веб-сервер, который застрял в бесконечном цикле и не может обрабатывать новые подключения, даже если серверный процесс все еще работает.

Когда для контейнера указана проверка работоспособности, он имеет статус работоспособности в дополнение к своему обычному статусу. Этот статус изначально starting. Всякий раз, когда проверка работоспособности проходит, он становится healthy (в каком бы состоянии он ни был ранее). После определенного количества последовательных отказов он становится unhealthy.

Опции инструкции:
- --interval=DURATION (default: 30s)
- --timeout=DURATION (default: 30s)
- --start-period=DURATION (default: 0s)
- --retries=N (default: 3)

## SHELL






