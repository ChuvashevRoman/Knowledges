# Глава 6. Классы.

## Основные понятия

Пример простого класса:
```cpp
// smallobj.cpp
// демонстрирует простой небольшой объект
#include <iostream>
using namespace std;

class smallobj			// определение класса
{
	private:
		int somedata;	// поле класса
	public:
	void setdata(int d)	// метод класса, изменяющий значение поля
		{ somedata = d; } 
	void showdata() 	// метод класса, отображающий значение поля
		{ cout << "Значение поля равно " << somedata << endl; }
};

int main()
{
	smallobj s1, s2;	// определение двух объектов класса smallobj
	s1.setdata(1066);	// вызовы метода setdata()
	s2.setdata(1776);
	s1.showdata();		// вызовы метода showdata()
	s2. showdata();
	return 0;
}
```

Определение класса производится в результате введения идентификатора `class`.
Если необходимо защитить какиелибо данные, то их помещают внутрь класса с ключевым словом `private`. Такие данные доступны только внутри класса. Данные, описанные с ключевым словом `public`, напротив, доступны за пределами класса.
Данные или **атрибуты** класса - это переменные объявлённые в теле самого класса, например в программе выше - это `int somedata`.

Методы класса - это функции, входящие в состав класса. В данном случае - это `void setdata` и `void showdata()`.

Как правило, скрывая данные класса, его методы оставляют доступными. Это объясняется тем, что данные скрывают с целью избежать нежелательного внешнего воздействия на них, а функции, работающие с этими данными, должны обеспечивать взаимодействие между данными и внешней по отношению к классу частью программы.

В некоторых объектно-ориентированных языках программирования вызовы методов объектов называют **сообщениями**.

### Конструкторы

**Конструктор** — это метод класса, выполняющийся автоматически в момент создания объекта.



## Принципы SOLID

### S - Single Responsibility Principle - принцип единственной ответственности.

Каждый класс должен иметь только одну зону ответственности. Необходимо разделять классы, чтобы предоставить возможность каждому классу отвечать только за одну зону или действие. Так в дальнейшем данный класс будет проще модифицировать или дополнять.

**Назначение:**
Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.

### O - Open closed Principle - принцип открытости-закрытости.

Классы должны быть открыты для расширения, но закрыты для изменения. Для того чтобы придерживаться принципа открытости-закрытости необходимо спроектировать код таким образом, чтобы каждый мог повторно использовать нашу функцию, просто расширив ее.

**Назначение**
Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс. 

### L - Liskov substitution Principle - принцип подстановки Барбары Лисков.

Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться. Для того чтобы следовать принципу подстановки Барбары Лисков необходимо в базовый (родительский) класс выносить только общую логику, характерную для классов наследников, которые будут ее реализовывать и, соответственно, можно будет базовый класс без проблем заменить на его класс-наследник. 

**Назначение**
Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.

### I -  Interface Segregation Principle - принцип разделения интерфейсов.

Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения. Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.

**Назначение**
Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.

### D - Dependency Inversion Principle - принцип инверсии зависимостей.

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента
Модули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операций
Абстракции – представляют интерфейс, соединяющий два класса
Детали = специфические характеристики работы инструмента

Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.

**Назначение**
Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.