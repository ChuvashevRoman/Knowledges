# Глава 6. Классы.

## Основные понятия

Пример простого класса:
```cpp
// smallobj.cpp
// демонстрирует простой небольшой объект
#include <iostream>
using namespace std;

class smallobj			// определение класса
{
	private:
		int somedata;	// поле класса
	public:
	void setdata(int d)	// метод класса, изменяющий значение поля
		{ somedata = d; } 
	void showdata() 	// метод класса, отображающий значение поля
		{ cout << "Значение поля равно " << somedata << endl; }
};

int main()
{
	smallobj s1, s2;	// определение двух объектов класса smallobj
	s1.setdata(1066);	// вызовы метода setdata()
	s2.setdata(1776);
	s1.showdata();		// вызовы метода showdata()
	s2. showdata();
	return 0;
}
```

Определение класса производится в результате введения идентификатора `class`.
Если необходимо защитить какиелибо данные, то их помещают внутрь класса с ключевым словом `private`. Такие данные доступны только внутри класса. Данные, описанные с ключевым словом `public`, напротив, доступны за пределами класса.
Данные или **атрибуты** класса - это переменные объявлённые в теле самого класса, например в программе выше - это `int somedata`.

**Методы класса** - это функции, входящие в состав класса. В данном случае - это `void setdata` и `void showdata()`.

Как правило, скрывая данные класса, его методы оставляют доступными. Это объясняется тем, что данные скрывают с целью избежать нежелательного внешнего воздействия на них, а функции, работающие с этими данными, должны обеспечивать взаимодействие между данными и внешней по отношению к классу частью программы.

В некоторых объектно-ориентированных языках программирования вызовы методов объектов называют **сообщениями**.

### Конструкторы

**Конструктор** — это метод класса, выполняющийся автоматически в момент создания объекта.

Счётчик из примера:
```cpp
class Counter
{
	private:
		unsigned int count;		// значение счетчика
	public:
		Counter() : count(0)	// конструктор
			{ /* пустое тело */ }
		void inc_count()		// инкрементирование счетчика
			{ count++; }
		int get_count()			// получение значения счетчика
			{ return count; }
};
```

Особенности конструктора:
1. Имя конструктора полностью совпадает с именем класса
1. У конструкторов не существует возвращаемых значений

Одна из наиболее важных функций конструктора - инициализация полей объекта класса. В случае указанном выше конструктор инициализирует значение счётчика равное нулю. Если необходимо проинициализировать несколько полей - значения разделяются запятой.
Инициализацию внутря тела конструктора лучше не производить. В теле конструктора как правило производятся более сложные операции.
Также при использовании конструктора можно задавать значения, которые могут быть инициализированы при определении класса:
```cpp
circle(int x, int y, int r, color fc, fstyle fs):
xCo(x), yCo(y), radius(r), fillcolor(fc), fillstyle(fs)
{ }
```

### Деструкторы

Деструктор - функция, которая вызывается при уничтожении объекта.
Пример:
```cpp
class Foo
{
private:
	int data;
public:
	Foo() : data(0)	// конструктор
		{}
	~Foo()			// деструктор
		{}
}
```

### Перегрузка конструктора
В случае если необходимо иметь возможность, как автоматически определять поля класса, так и вводить данные - можно использовать перегруженный конструктор. Для этого необходимо несколько раз определить конструктор. Например:
```cpp
Distance() : feet(0), inches(0.0)
	{ }
Distance(int ft, float in) : feet(ft), inches(in)
	{ }
```

В результате в теле основной функции можно определять класс поразному:
```cpp
Distance dist1, dist3;
Distance dist2(11, 6.25);
```

### Определение методов класса вне класса

Также можно определять методы класса вне его. Например в программе, описанной ниже:
```cpp
#include <iostream>
using namespace std;
class Distance	// длина в английской системе
{
private:
	int feet;
	float inches;
public:
	// конструктор без аргументов
	Distance() : feet(0), inches(0.0)
		{ }
	// конструктор с двумя аргументами
	Distance(int ft, float in) : feet(ft), inches(in)
		{ }
	void getdist()						// ввод длины пользователем
	{
		cout << "\nВведите число футов: "; cin >> feet;
		cout << "Введите число дюймов: "; cin >> inches;
	}
	void showdist()						// вывод длины на экран
		{ cout << feet << "\'-" << inches << '\"'; }
	void add_dist(Distance, Distance);	// прототип
};
//--------------------------------------------------------
// сложение длин d1 и d2
void Distance::add_dist(Distance dd1, Distance dd2)
{
	inches = dd1.inches + dd2.inches;
	feet = 0;
	if(inches >= 12.0)
	{
		inches -= 12.0;
		feet++;
	}
	feet += dd1.feet + dd2.feet;
}

int main()
{
	Distance dist1, dist3;
	Distance dist2(11, 6.25);
	dist1.getdist();
	dist3.add_dist(dist1, dist2); // dist3 = dist1 + dist2
	cout << "\ndist1 = "; dist1.showdist();
	cout << "\ndist2 = "; dist2.showdist();
	cout << "\ndist3 = "; dist3.showdist();
	cout << endl;
	return 0;
}
```

### Копирующий конструктор

Копирующий конструктор использует значение полей уже существующего класса. Для его использование не нужно создавать отдельный конструктор. Достаточно использовать в основной функции: `Distance dist2(dist1);` или `Distance dist3 = dist1;`. Опирации присваивания в первом и во втором случае не происходят. В данном случае создаётся отдельный объект, данные которого копируются из `dist1`.

### Структуры и классы

В структурах также могут быть использованы и функции. Отличие структур от классов - то что в классах по умолчанию объекты скрыты, а в структурах - открыты. Поэтому для упрощённого написания можно использовать следующий формат для определения структур и классов:

```cpp
class foo
{
	int data1;
	public:
		void func();
};
```

```cpp
struct foo
{
	void func();
	private:
		int data1;
};
```

Обычно программисты разделяют использование структур для объединения данных, а классы для объединения данных и функций в объекты.

### Статическая переменная класса

Переменная описанная с ключевым словом `static` является общей для всех объектов класса. Статическое поле по своим характеристикам схоже со статической переменной: оно видимо только внутри класса, но время его жизни совпадает со временем жизни программы.

### Константные методы

Константные методы отличаются тем, что не изменяют значений полей своего класса.
Объявляются следующим образом `void func() const { }`

Также константными можно сделать и сами объекты.

## Принципы SOLID

### S - Single Responsibility Principle - принцип единственной ответственности.

Каждый класс должен иметь только одну зону ответственности. Необходимо разделять классы, чтобы предоставить возможность каждому классу отвечать только за одну зону или действие. Так в дальнейшем данный класс будет проще модифицировать или дополнять.

**Назначение:**
Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.

### O - Open closed Principle - принцип открытости-закрытости.

Классы должны быть открыты для расширения, но закрыты для изменения. Для того чтобы придерживаться принципа открытости-закрытости необходимо спроектировать код таким образом, чтобы каждый мог повторно использовать нашу функцию, просто расширив ее.

**Назначение**
Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс. 

### L - Liskov substitution Principle - принцип подстановки Барбары Лисков.

Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться. Для того чтобы следовать принципу подстановки Барбары Лисков необходимо в базовый (родительский) класс выносить только общую логику, характерную для классов наследников, которые будут ее реализовывать и, соответственно, можно будет базовый класс без проблем заменить на его класс-наследник. 

**Назначение**
Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.

### I -  Interface Segregation Principle - принцип разделения интерфейсов.

Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения. Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.

**Назначение**
Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.

### D - Dependency Inversion Principle - принцип инверсии зависимостей.

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента
Модули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операций
Абстракции – представляют интерфейс, соединяющий два класса
Детали = специфические характеристики работы инструмента

Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.

**Назначение**
Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.

