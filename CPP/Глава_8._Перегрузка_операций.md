# Перегрузка операций

Перегрузка операций позволяет упростить сложный листинг программы в интуитивно-понятный. Например строки `d3.addobjects(d1, d2);` и `d3 = d1.addobjects(d2)` можно заменить на более читаемую `d3 = d1 + d2`.

## Перегрузка унарных операций

Пример унарной операции - инкремент (++) и декремент(--).
Пример класса с перегрузкой по инкременту:

```cpp
class Counter
{
private: 
	unsigned int count;
public:
	Counter() : count (0) {} 		//конструктор
	unsigned int get_count() { 		// получение значения
		return count;
	} 
	void operator++() {				// увеличить на единицу
		++count;
	}
};
```

`void operator++()` определяет перегружаемую функцию. В данном случае тип `void` не позволяет вернуть в результате операции значение. Поэтому операция типа `c2 = c1++` приведёт к ошибке. Чтобы избежать данную ошибку можно модернизировать функцию.

```cpp
Counter operator++() {
	++count;
	Counter temp;
	temp.count = count;
	return temp;
}
```

`++c1` - увеличивает с1 на 1
`c2 = ++c1` - увеличивает с1 на 1 и копирует значение с1 в с2
Функция `operator++()` создаёт новый объект класса **Counter** для использования его в качестве возвращаемого значения.

Также подобный пример можно реализовать с помощью:

```cpp
Counter operator++() {
	++count;
	return Counter(count);
}
```

В данном случае временный объект **Counter** просто не имеет имени.

### Постфиксные операции

В случае если необходимо использовать постфиксную запись, где переменная увеличивается после того, как её значение было использовано в выражении, можно использовать конструкцию:
```cpp
Counter operator++() {
	return Counter(++count);
}

Counter operator++(int) {
	return Counter(count++);
}
```
В результате можно использовать как операцию `++c`, так и `c++`.
Различие между двумя операциями только в том, что во втором случае стоит в скобках **int**, что даёт сигнал компилятору, чтобы использовалась постфиксная версия операции.

## Перегрузка бинарных операций

### Арифметические операции
`d3 = d1 + d2;`
Пример перегрузки с операцией сложения длин:
```cpp
Distance operator+(Distance d2) const {
	int f = feet +d2.feet;
	float i = inches + d2.inches;
	if(i > 12.0) {
		i -= 12;
		f++;
	}
	return Distance(f, i)
};
```

### Операции сравнения
`d1 < d2`
```cpp
bool Distance::operator<(Distance d2) const
{
	float bf1 = feet + inches / 12;
	float bf2 = d2.feet + d2.inches / 12;
	return (bf1 < bf2) ? true : false;
}
```

### Операции арифметического присваивания
`d1 += d2`
```cpp
void Distance::operator+=(Distance d2)
{
	feet += d2.feet;		// складываем футы
	inches += d2.inches; 	// складываем дюймы
	if(inches >= 12.0)		// если дюймов больше 12
	{
		inches -= 12.0;		// то уменьшаем дюймы на 12
		feet++;				// увеличиваем футы на 1
	}
}
```

### Операция индексации массива ([])
Доступ к отдельным элементам массива можно осуществлять при помощи дополнительных методов. Например:
```cpp
class safearray
{
	private:
		int arr[LIMIT];
	public:		// установка значения элемента массива
		void putel(int n, int elvalue)
		{
			if(n < 0 || n >= LIMIT)
				cout << "\nОшибочный индекс!"; exit(1);
			arr[n] = elvalue;
		}	// получение значения элемента массива
		int getel(int n) const
		{
			if(n < 0 || n >= LIMIT)
				cout << "\nОшибочный индекс!"; exit(1);
			return arr[n];
		}
};
```
В данном случае функция `arr1.putel(j, j*10)` позволяет положить в *j-й* элемент массива значение `j*10`. Функция `arr1.getel(j)` позволяет получить *j-й* элемент массива. Но можно использовать и одну функцию при помощи возвращения по ссылки:
```cpp
class safearray
{
	private:
		int arr[LIMIT];
	public:		// установка значения элемента массива
		int& access(int n)
		{
			if(n < 0 || n >= LIMIT)
				cout << "\nОшибочный индекс!"; exit(1);
			return arr[n];
		}
};
```
В результате можно совершать операции как `sa1.access(j) = j * 10`, так и `int temp = sa1.access(j)`. 
Также можно использовать перегруженную операцию с `[]`:
```cpp
class safearray
{
	private:
		int arr[LIMIT];
	public:
		int& operator[](int n)
		{
			if(n < 0 || n >= LIMIT)
				cout << "\nОшибочный индекс!"; exit(1);
			return arr[n];
		}
};
```
Используя данный класс можно применять запись индексации массива `arr1[j] = j * 10` или `int temp = arr1[j]`.

## Преобразование типов

