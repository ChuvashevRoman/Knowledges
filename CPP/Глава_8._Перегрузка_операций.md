# Перегрузка операций

Перегрузка операций позволяет упростить сложный листинг программы в интуитивно-понятный. Например строки `d3.addobjects(d1, d2);` и `d3 = d1.addobjects(d2)` можно заменить на более читаемую `d3 = d1 + d2`.

## Перегрузка унарных операций

Пример унарной операции - инкремент (++) и декремент(--).
Пример класса с перегрузкой по инкременту:

```cpp
class Counter
{
private: 
	unsigned int count;
public:
	Counter() : count (0) {} 		//конструктор
	unsigned int get_count() { 		// получение значения
		return count;
	} 
	void operator++() {				// увеличить на единицу
		++count;
	}
};
```

`void operator++()` определяет перегружаемую функцию. В данном случае тип `void` не позволяет вернуть в результате операции значение. Поэтому операция типа `c2 = c1++` приведёт к ошибке. Чтобы избежать данную ошибку можно модернизировать функцию.

```cpp
Counter operator++() {
	++count;
	Counter temp;
	temp.count = count;
	return temp;
}
```

`++c1` - увеличивает с1 на 1
`c2 = ++c1` - увеличивает с1 на 1 и копирует значение с1 в с2
Функция `operator++()` создаёт новый объект класса **Counter** для использования его в качестве возвращаемого значения.

Также подобный пример можно реализовать с помощью:

```cpp
Counter operator++() {
	++count;
	return Counter(count);
}
```

В данном случае временный объект **Counter** просто не имеет имени.

### Постфиксные операции

В случае если необходимо использовать постфиксную запись, где переменная увеличивается после того, как её значение было использовано в выражении, можно использовать конструкцию:
```cpp
Counter operator++() {
	return Counter(++count);
}

Counter operator++(int) {
	return Counter(count++);
}
```
В результате можно использовать как операцию `++c`, так и `c++`.
Различие между двумя операциями только в том, что во втором случае стоит в скобках **int**, что даёт сигнал компилятору, чтобы использовалась постфиксная версия операции.

## Перегрузка бинарных операций

### Арифметические операции
`d3 = d1 + d2;`
Пример перегрузки с операцией сложения длин:
```cpp
Distance operator+(Distance d2) const {
	int f = feet +d2.feet;
	float i = inches + d2.inches;
	if(i > 12.0) {
		i -= 12;
		f++;
	}
	return Distance(f, i)
};
```

### Операции сравнения
`d1 < d2`
```cpp
bool Distance::operator<(Distance d2) const
{
	float bf1 = feet + inches / 12;
	float bf2 = d2.feet + d2.inches / 12;
	return (bf1 < bf2) ? true : false;
}
```

### Операции арифметического присваивания
`d1 += d2`
```cpp
void Distance::operator+=(Distance d2)
{
	feet += d2.feet;		// складываем футы
	inches += d2.inches; 	// складываем дюймы
	if(inches >= 12.0)		// если дюймов больше 12
	{
		inches -= 12.0;		// то уменьшаем дюймы на 12
		feet++;				// увеличиваем футы на 1
	}
}
```

### Операция индексации массива ([])
Доступ к отдельным элементам массива можно осуществлять при помощи дополнительных методов. Например:
```cpp
class safearray
{
	private:
		int arr[LIMIT];
	public:		// установка значения элемента массива
		void putel(int n, int elvalue)
		{
			if(n < 0 || n >= LIMIT)
				cout << "\nОшибочный индекс!"; exit(1);
			arr[n] = elvalue;
		}	// получение значения элемента массива
		int getel(int n) const
		{
			if(n < 0 || n >= LIMIT)
				cout << "\nОшибочный индекс!"; exit(1);
			return arr[n];
		}
};
```
В данном случае функция `arr1.putel(j, j*10)` позволяет положить в *j-й* элемент массива значение `j*10`. Функция `arr1.getel(j)` позволяет получить *j-й* элемент массива. Но можно использовать и одну функцию при помощи возвращения по ссылки:
```cpp
class safearray
{
	private:
		int arr[LIMIT];
	public:		// установка значения элемента массива
		int& access(int n)
		{
			if(n < 0 || n >= LIMIT)
				cout << "\nОшибочный индекс!"; exit(1);
			return arr[n];
		}
};
```
В результате можно совершать операции как `sa1.access(j) = j * 10`, так и `int temp = sa1.access(j)`. 
Также можно использовать перегруженную операцию с `[]`:
```cpp
class safearray
{
	private:
		int arr[LIMIT];
	public:
		int& operator[](int n)
		{
			if(n < 0 || n >= LIMIT)
				cout << "\nОшибочный индекс!"; exit(1);
			return arr[n];
		}
};
```
Используя данный класс можно применять запись индексации массива `arr1[j] = j * 10` или `int temp = arr1[j]`.

## Преобразование типов
Преобразование основных типов в основные типы можно производить в результате операции присваивания как например `intvar = floatvar;`, где *intvar* - имеет тип int, а *floatvar* - float; так и в результате операции `intvar = static_cast<int>(floatvar);`. 

В случае преобразования определённых пользователем типов в основные необходимо отдельно указать функции для их преобразования. Пример в следующей программе:
```cpp
// перевод длины из класса Distance в метры и обратно
#include <iostream>
using namespace std;
///////////////////////////////////////////////////////////
class Distance								// класс английских мер длины
	{
	private:
		const float MTF;					// коэффициент перевода метров в футы
		int feet;
		float inches;
	public:	
	// конструктор без параметров
		Distance() : feet(0), inches(0.0), MTF(3.280833F)
			{ }
	// конструктор с одним параметром,
	// переводящий метры в футы и дюймы
	Distance(float meters) : MTF(3.280833F)
		{
			float fltfeet = MTF * meters;	// переводим в футы
			feet = int(fltfeet);			// берем число полных футов
			inches = 12 * (fltfeet - feet); // остаток — это дюймы
		}
	// конструктор с двумя параметрами
	Distance(int ft, float in) : feet(ft), inches(in), MTF(3.280833F)
		{ }
	// получение информации от пользователя
	void getdist()
		{
			cout << "\nВведите футы: "; cin >> feet;
			cout << "Введите дюймы: "; cin >> inches;
		}
	// показ информации
	void showdist() const
		{ cout << feet << "\'-" << inches << '\"'; }
	// оператор перевода для получения метров из футов
	operator float() const
		{
			float fracfeet = inches / 12;	// переводим дюймы в футы
			fracfeet += static_cast<float>(feet); // добавляем целые футы
			return fracfeet / MTF;			// переводим в метры
		}
	};
///////////////////////////////////////////////////////////
int main()
{
	float mtrs;
	Distance dist1 = 2.35F; 				// используется конструктор, переводящий метры в футы и дюймы
	cout << "\ndist1 = "; dist1.showdist();

	mtrs = static_cast<float>(dist1);		// используем оператор перевода в метры
	cout << "\ndist1 = " << mtrs << "meters\n";
	Distance dist2(5, 10.25);				// используем конструктор с двумя параметрами
	mtrs = dist2;							// неявно используем перевод типа
	cout << "\ndist2 = " << mtrs << "meters\n";
	// dist2 = mtrs; 						// а вот это ошибка - так делать нельзя
	return 0;
}
```
В программе, представленной выше, конструктор `Distance(float meters)` позволяет сразу преобразовать метры в из типа float в определённый объект Distance. Этот метод вызывается, когда объект класса Distance создаётся с одним аргументом.

Оператор `float()` позволяет компилятору понять, каким образом преобразовывать объект класса Distance в значение типа float.

Преобразование можно производить также между классами, определёнными пользователем. Пример ниже:
```cpp
#include <iostream>
#include <string>
using namespace std;
///////////////////////////////////////////////////////////
class time12
{
	private:
		bool pm;							// true = pm, false = am
		int hrs;							// 1 - 12
		int mins;							// 0 - 59
	public:
		// конструктор без аргументов
		time12() : pm(true), hrs(0), mins(0)
			{ }
		// конструктор с тремя аргументами
		time12(bool ap, int h, int m) : pm (ap), hrs (h), mins (m)
			{ }
		void display() const // формат: 23:59.
			{
				cout << hrs << ':';
				if(mins < 10) cout << '0'; // дополнительный нуль для "01"
				cout << mins << ' ';
				string am_pm = pm ? "p.m." : "a.m.";
				cout << am_pm;
			}
};

class time24
{
	private:
		int hours;							// 0 - 23
		int minutes;						// 0 - 59
		int seconds;						// 0 - 59
	public:
		// конструктор без аргументов
		time24() : hours(0), minutes(0), seconds(0)
			{ }
		// конструктор с тремя аргументами
		time24(int h, int m, int s) : hours(h), minutes(m), seconds(s)
			{ }
		void display() const 				// формат: 23:15:01
			{
				if(hours < 10) cout << '0';
				cout << hours << ':';
				if(minutes < 10) cout << '0';
				cout << minutes << ':';
				if(seconds < 10) cout << '0';
				cout << seconds;
			}
		operator time12() const;			// оператор преобразования
};

time24::operator time12() const				// оператор преобразования
{
	int hrs24 = hours;
	bool pm = hours < 12 ? false : true; 	// определение am/pm
											// округление секунд
	int roundMins = seconds < 30 ? minutes : minutes + 1;
	if(roundMins == 60)
	// переносим минуты?
		{
			roundMins = 0;
			++hrs24;
			if(hrs24 == 12 || hrs24 == 24)	// переносим часы?
			pm = (pm == true) ? false : true; // переключатель am/pm
		}
	int hrs12 = (hrs24 < 13) ? hrs24 : hrs24 - 12;
	if(hrs12 == 0)	// 00 это 12 a.m.
		{
			hrs12 = 12;
			pm = false;
		}
	return time12(pm, hrs12, roundMins);
}

int main()
{
	int h, m, s;

	while(true)
	{
		// получение времени в 24-ом формате от пользователя
		cout << "Введите время в 24-часовом формате: \n";
		cout << " Часы (от 0 до 23): "; cin >> h;
		if(h > 23)	// выход, если часов > 23
			return (1);
		cout << " Минуты: "; cin >> m;
		cout << " Секунды: "; cin >> s;
		
		time24 t24(h, m, s);				// сделать время в 24-часовом формате
		cout << "Исходное время: ";
		t24.display();						// вывести на экран время в 24-часовом формате
		
		time12 t12 = t24;					// преобразовать time24 - time12
		
		cout << "\nВ 12-часовом формате: ";
		t12.display();						// вывести на экран время в 12-часовом формате
		cout << "\n\n";
	}
	return 0;
}
```
Если имеется возможность получить доступ к объекту класса назначения, то нужно использовать конструктор с одним аргументом. Если же объект назначения принадлежит библиотечному классу, то нужно использовать операцию преобразования в исходном классе.

Классы могу иметь различные виды взаимоотношений. Объединение классов подразумевает, что объекты классов, в большей степени, чем сами классы, имеют взаимосвязи.

## Нюансы исполтзования перегрузки
- Используйте перегрузку операций для выполнения действий, которые можно выполнить с помощью основных типов данных. Например, вы можете перегрузить знак + для выполнения вычитания, но едва ли это сделает ваш листинг более понятным.
- Используйте перегруженные операции так же, как и основные.
- Если у вас очень много перегруженных операций, и они используются для не понятных интуитивно целей, то потеряется суть их использования и чтение листинга станет тяжелее вместо того, чтобы стать легче.
- Следующие операции не могут быть перегружены: операция доступа к членам структуры или класса `(.)`, операция разрешения `(::)` и операция условия `(?:)`. А также операция `( -> )`, с которой мы еще не сталкивались. Кроме того, нельзя создавать новые операции (например, нельзя определить новую операцию возведения в степень `**`, которая есть в некоторых языках) и пытаться их перегрузить; перегружать можно только существующие операции.

Конструктор, объявленный с ключевым словом explicit, не может быть использован в ситуации неявного преобразования данных. Данные, объявленные с ключевым словом mutable, могут быть изменены, даже если их объект объявлен как const.