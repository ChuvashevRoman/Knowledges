# Массивы

Массивы объединяют некоторое количество элементов одинакового типа в один блок.
Определение массива из типов **int** происходит следующим образом `int arr[4]`. В данном случае определяется массив **arr** состоящий из 4-х элементов типа **int**. Количество элементов массива ограничено и задаётся при определении.
Нумерация элементов массива начинается с 0.
Доступ к элементам массива производится `arr[j]`, где **j** - номер элемента.

Инициализация массива может производиться как поэлементно, так и сразу, например `int days_per_month[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };`.
При инициализации всех элементов можно не указывать их количество в квадратных скобках.

Массивы могут быть также многомерными `arr[i][j]`.

при использовании массива в качестве агрумента функции можно не указывать только размерность первого массива, размерность подмассивов необходимо указывать `void display(double[][MONTHS]);`. При определении функций необходимо указывать квадратные скобки и размерность.

При вызове функции с массивом используется только имя массива `display(sales);`. 

## Массивы в классах на примере Стека

Программа:
```cpp
// stakaray.cpp
// класс стек
#include <iostream>
using namespace std;

class Stack
{
	private:
		enum { MAX = 10 };	// немного нестандартный синтаксис
		int st[MAX];		// стек в виде массива
		int top;			// вершина стека
	public:
	Stack()					// конструктор
		{ top = 0; }
	void push(int var) 		// поместить в стек
		{ st[++top] = var; }
	int pop()				// взять из стека
		{ return st[top--]; }
};

int main()
{
	Stack s1;
	s1.push(11);
	s1.push(22);
	cout << "1: " << s1.pop() << endl;
	cout << "2: " << s1.pop() << endl;
	s1.push(33);
	s1.push(44);
	s1.push(55);
	s1.push(66);
	cout << "3: " << s1.pop() << endl;
	cout << "4: " << s1.pop() << endl;
	cout << "5: " << s1.pop() << endl;
	cout << "6: " << s1.pop() << endl;
	return 0;
}
```

В данном примере метод **push** присваивает верхнему элементу массива **st** новое значение, тем самым помещает в стек, а метод **pop** берёт из стека верхнее число.
Размер массива, используемого для стека, определяется переменной MAX в строке `enum { MAX = 10 };`. Стандарт C++ дает возможность объявления константы MAX внутри класса: `static const int MAX = 10;`. К сожалению, некоторые компиляторы не позволяют использовать эту конструкцию.

## Границы массивов

Если программа поместит что-то за пределами массива, то компилятор и исполняемая программа протестовать не будут. Однако эти данные могут быть записаны поверх других данных или поверх самой программы. Это может послужить причиной странных эффектов или даже полного краха системы. В некоторых случаях нужно задавать большой размер массива и делать защиту на случай переполнения.

# Строки

## Строка символов Char

Строку можно записывать как массив символов `char str[] = "Welcome!";`.
Можно также задавать строку при вводе символов через `cin`, при этом существует возможность переполнения буфера. Для защиты от переполнения можно использовать `cin >> setw(MAX) >> str;`. В данном случае `setw(MAX)` не даст ввести больше символов, чем число MAX. 
При введении строки с пробелами можно использовать конструкцию `cin.get(str, MAX);`. Для считывания нескольких строк можно задать символ, который будет сигнализировать об окончании ввода текста `cin.get(str, MAX, '$');`.

### Копирование строк

Копирование строк можно производить в цикле **fot** поэлементно, а также с помощью функции **strcpy** из библиотеки **<cstring>** `strcpy(str2, str1);`.

## Класс String

Класс подключается дополнительной библиотекой `#include <string>`.
Класс String позволяет упростить использование строк. Например позволяет использовать перегруженные операции `s3 = s1 + s2;`, которая присваивает строке s3 объединённую строку s1 и s2.

### Ввод для объекта класса String

Ввод данных в строку осуществляется при помощи функции. getline(). Эта функция похожа на метод get(), используемый для строкового типа, но это не метод класса. Ее первым аргументом является потоковый объект, из которого будет приниматься ввод (здесь это cin), а второй аргумент — это объект класса string, куда будет помещен текст.

### Доп методы класса String 

1. **find()** - предназначен для поиска строки, используемой в качестве аргумента в строке. Возвращает позицию первого найденного. `n = s1.find("asd");`. Поиск с конца строки - **rfind()**.
1. **find_first_of()** - ищет первый символ в строке, который соотвествует любому символу из группы. Поиск с конца строки - **find_last_of()**
1. **find_first_not_of()** - ищет первый символ в строке, который не входит в определённую группу. Поиск с конца строки **find_last_not_of()**.
1. **erase(0, 12)** - удаляет фрагмент из строки (в данном случае от 0 до 12 символа).
1. **s1.replace(11, 7, s2)** - заменяет фрагмент (в данном случае начиная с 11 семь символов на строку s2).
1. **s1.insert(0, s3)** - вставляет с определённого символа строку.
1. **append(3, '!')** - добавляет символы в указанном количестве.
1. **length()** и **size()** определяют размер строки.
1. **capacity()** - возвращает действительное количество памяти на строку.
1. **strcpy(str2, str1)** - копирование строки *str1* в *str2*.
1. **strcat(str1, str2)** - добавление строки *str2* вконец *str1*.
1. **strcmp(str1, str2)** сравнение двух строк.

